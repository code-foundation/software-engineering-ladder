# SE Ladder 00: Introduction

## Assumptions
The requirements of the level are the entry requirements. Since people are hired into roles based on their ability, it's unfair to promote to that level without also meeting the same requirements. While it's understood that sometimes an engineer may not be exactly 100% of the requirements for a given level, it's fair to assume that 

## Terminology
* Level of autonomy: The size of codebase, team, or structure a person should be expected to own and work on without outside help on a regular basis. This doesn't mean a developer at this level can't ask for help below or at this level, but it's the conceptual size they should be comfortable at.
* Skills: Skills the developer should understand, and be able to explain.
* Toolchain: How well the developer should understand the tools that help build, manage, and test code. This includes, but is not limited to; Git, standards tools, CI, IDE and general workstation setup. 
* Communication: The level of discussion the developer should be able to offer.
* Task management: The amount of time the persons manager needs to be spend managing this person directly. Less is almost always better.
* Peer review: The interaction the developer should have with the peer review process.
* Architecture: How much influence on overall system architecture a developer at this position is expected to have.
* Mentoring: If and and how much engineer is expected to mentor and educate other engineers.
* Anti-patterns are common patterns at this level that developers fall into. While falling into them is not a failing problem, conquering them is required to move up to the next level.
* Self-education: Commentary, links, and discussion about where and how engineers at this level can improve themselves.
* Mentoring Of: Discussion around the mentoring of engineers at this level.

## Stacking
Everything stacks. That is, skills in a lower level are implicitly required in all levels above.

## Bias
This is written with the experience and target in mind of a software engineers working in SaaS product based roles, centered around OOP languages for backend engineering. However, the assumptions should be broadly applicable.
